{"version":3,"names":["_core","require","buildClassDecorator","template","statement","buildClassPrototype","buildGetDescriptor","buildGetObjectInitializer","WARNING_CALLS","WeakSet","applyEnsureOrdering","path","decorators","isClass","get","reduce","acc","prop","concat","node","identDecorators","filter","decorator","t","isIdentifier","expression","length","sequenceExpression","map","id","scope","generateDeclaredUidIdentifier","assignmentExpression","applyClassDecorators","classPath","hasClassDecorators","name","dec","reverse","CLASS_REF","cloneNode","DECORATOR","INNER","classNode","applyMethodDecorators","state","hasMethodDecorators","body","applyTargetDecorators","some","_node$decorators","applyObjectDecorators","properties","type","decoratedProps","exprs","computed","buildCodeFrameError","property","isLiteral","key","stringLiteral","target","static","isClassProperty","descriptor","initializer","value","functionExpression","blockStatement","returnStatement","nullLiteral","callExpression","addHelper","thisExpression","add","push","arrayExpression","objectExpression","objectProperty","identifier","booleanLiteral","isObjectProperty","TEMP","TARGET","PROPERTY","decoratedClassToExpression","ref","generateUidIdentifier","variableDeclaration","variableDeclarator","toExpression","visitor","ExportDefaultDeclaration","decl","isClassDeclaration","replacement","varDeclPath","replaceWithMultiple","exportNamedDeclaration","exportSpecifier","declarations","registerDeclaration","ClassDeclaration","newPath","replaceWith","binding","getOwnBinding","ClassExpression","decoratedClass","ObjectExpression","decoratedObject","AssignmentExpression","has","right","CallExpression","arguments","callee","_default","exports","default"],"sources":["../src/transformer-legacy.ts"],"sourcesContent":["// Fork of https://github.com/loganfsmyth/babel-plugin-proposal-decorators-legacy\n\nimport { template, types as t, type PluginPass } from \"@babel/core\";\nimport type { NodePath, Visitor } from \"@babel/traverse\";\n\nconst buildClassDecorator = template.statement(`\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n`) as (replacements: {\n  DECORATOR: t.Expression;\n  CLASS_REF: t.Identifier;\n  INNER: t.Expression;\n}) => t.ExpressionStatement;\n\nconst buildClassPrototype = template(`\n  CLASS_REF.prototype;\n`) as (replacements: { CLASS_REF: t.Identifier }) => t.ExpressionStatement;\n\nconst buildGetDescriptor = template(`\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n`) as (replacements: {\n  TARGET: t.Expression;\n  PROPERTY: t.Literal;\n}) => t.ExpressionStatement;\n\nconst buildGetObjectInitializer = template(`\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n`) as (replacements: {\n  TEMP: t.Identifier;\n  TARGET: t.Expression;\n  PROPERTY: t.Literal;\n}) => t.ExpressionStatement;\n\nconst WARNING_CALLS = new WeakSet();\n\n// legacy decorator does not support ClassAccessorProperty\ntype ClassDecoratableElement =\n  | t.ClassMethod\n  | t.ClassPrivateMethod\n  | t.ClassProperty\n  | t.ClassPrivateProperty;\n\n/**\n * If the decorator expressions are non-identifiers, hoist them to before the class so we can be sure\n * that they are evaluated in order.\n */\nfunction applyEnsureOrdering(\n  path: NodePath<t.ClassExpression | t.ObjectExpression>,\n) {\n  // TODO: This should probably also hoist computed properties.\n  const decorators: t.Decorator[] = (\n    path.isClass()\n      ? [\n          path,\n          ...(path.get(\"body.body\") as NodePath<ClassDecoratableElement>[]),\n        ]\n      : path.get(\"properties\")\n  ).reduce(\n    (\n      acc: t.Decorator[],\n      prop: NodePath<\n        t.ObjectMember | t.ClassExpression | ClassDecoratableElement\n      >,\n    ) => acc.concat(prop.node.decorators || []),\n    [],\n  );\n\n  const identDecorators = decorator